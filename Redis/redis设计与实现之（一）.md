各位朋友大家好：
    首次见面 先自我介绍一下，：
	我是一名十年工作经验的码农，目前就职于。（如果大家有需要可以找内推啊）
      
今天我们来聊聊《Redis设计与实现》这本书。提到Redis相信很多码农都很熟悉。Redis是一个key-value存储系统，和Memcache类似，它支持存储的value类型相对更多，包括string(字符串)、list(列表)、set(集合)、zset(有序集合)和hash 以及订阅/发布等功能。但这本书并不是介绍怎么使用Redis的，而是对Redis的实现原理进行了介绍力图展示其核心数据结构以及关键的算法思想，并让我们能够快速、有效的了解Redis的内部构造以及其运作机制。敲黑板划重点了，**如果只是对Redis实现原理感兴趣，但是又不想深入研究Redis源代码，那么读这本书就够了。**（这是书上说的，不是我说的啊。我觉得时间充裕的还是可以看完对应章节，看下对应部分代码，毕竟Redis源码并不算多。有问题大家可以留言讨论）。

好，废话不多说，直奔主题。
      

## 简单动态字符串 SDS 
```
struct sdshdr {
	int len; //buf数组中已使用字节的数量,等于SDS所保存字符串的长度
	int free; // buf数组中未使用字节的数量
	char buf[]; // 字节数组，用于保存字符串
}
```

图中示例：

 - free 的值是0，表示这个SDS分配的空间都被用完了。
 - len 的值是5， 表示这个SDS 保存了5个字节长的字符串
 - buf属性是一个char类型的数组，数组的前五个字节分别保存了'R'、'e'、'd'、'i'、's'五个字符，而最后一个字节和C字符串一样'\0'表示结束'。
（但是最后一个字节'\0'是不计入len的。对SDS的使用者来说是透明的，我觉得这一点还是挺不错的。不用获得以后-1什么的。）



## 如此设计的优点：
感觉这个sds和C字符串的功能差不多都是存字符串的嘛。为毛要多此一举封装一个结构体呢。接下来讨论一下sds的点。

 1. 获取字符串长度复杂度O(1)。
 2. API安全，杜绝缓冲区溢出：如果buf由小变大，会自动判断buf大小是否足够，如果不够重新申请内存。归一化，避免内存溢出。
 3. 由于SDS的内存分配策略，减少修改字符串时带来的内存重新分配次数。避免频繁申请内存，内存拷贝，等io操作。


## 内存分配策略
 1. 如果申请内存大小 <1M 则直接分配1M内存。
 2. 如果申请内存大小 >1M 如5M 则多分配1M即 5+1M。

## 内存回收策略
惰性回收：刚才我们说了 buf由小变大，sds会自动判断大小，如果内存不足会申请内存，那么如果由大变小呢（如:原大小6M 现在只2个字节了），sds会变成1M大小的内存呢？还是维持原有大小64M呢？ 答案是维持原有大小，只是会改变free的值。
关于内存回收策略 我们后面会具体介绍。

留个话题讨论一下，那么Redis的sds最大可以存多大的字符串呢？
    


-----------------
Q&A:

1. redis在缓存上有什么显著的优势？使用场景？
2. 有哪些基本的数据结构类型？
3. redis是用什么语言写的呢？有没有什么扩展和插件？
3. 这本书是哪一年的，作者是谁呀？
4. 简单动态字符串为什么要额外定义一个len?
5. len + free 就等于buf的length吗？
6. 这么设计的优点？
7. 是怎么分配和管理内存的？
8. 如何回收内存？为什么说它是惰


[enter link description here](https://redis.io/topics/data-types)
    
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjM0NzEzNzQ2LDgzMzgwNDYyOSwtMTE5OD
QwNTc5Nl19
-->