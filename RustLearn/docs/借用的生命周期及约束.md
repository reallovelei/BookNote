昨天我们发现一个问题：
一旦 data 离开了作用域被释放，如果还有引用指向 data，就会造成我们想极力避免的使用已释放内存（use after free）这样的内存安全问题，该怎么办呢？ 这就引出了我们今天的主角。

## 借用的生命周期及其约束
所以在对值的引用也要有约束：借用不能超过值的生存周期。什么意思呢？  
说人话就是，生命周期短的可以借用生命周期长的，生命周期长的不能借用短的。

先看一下以下代码：
```rust
fn main() {
    let r = local_ref();
    println!("r: {:p}", r);
}

fn local_ref<'a>() -> &'a i32 {
    let a = 42;
    &a
}
```
这个case中，生命周期更长的 main() 函数变量 r ，引用了生命周期更短的 local_ref() 函数里的局部变量。
在Golang里会自动把a 逃逸到堆上。
但是在Rust中是编译不过去的。因为这样违背了引用约束。

好，说到这里我们还只是在学到了rust里的只读借用。有些情况我们需要在借用的过程中修改值的内容，这就需要用到**可变借用**

## 可变借用
在没有引入可变借用之前，因为一个值同一时刻只有一个所有者，所以如果要修改这个值，只能通过唯一的所有者进行。但是，如果允许借用改变值本身，会带来新的问题。我们先看第一种情况，**多个可变引用共存**：
```rust
fn main() {
    let mut data = vec![1, 2, 3];

    for item in data.iter_mut() {
        data.push(*item + 1);
    }
}
```
这段代码中，data.iter_mut() 方法 是 &mut，已经可变借用一次； 
然后在 {} 中，data.push() 方法 还是 &mut，
在第一次 &mut 期间，又 一次 &mut，在同一作用域下，多个可变引用，这是不合法的。
Rust 编译器阻止了这种情况，上述代码会编译出错。
如图1：
说人话就是：在同一作用域下，不能有多个可变引用。

那么如果有一个可变引用和多个只读引用，可以吗？
```rust
fn main() {
    let mut data = vec![1, 2, 3];
    let data1 = vec![&data[0]];
    println!("data[0]: {:p}", &data[0]);

    for i in 0..100 {
        data.push(i);
    }

    println!("data[0]: {:p}", &data[0]);
    println!("boxed: {:p}", &data1);
}
```

<img src="" />
可以从图中看到依然报错。


## Rust 的限制
为了保证内存安全，Rust对可变引用的使用做了严格的约束：
* 一个作用域内，仅允许一个活跃的可变引用。 这里提到的活跃是指，真正被用来修改数据的可变引用。如果只定义了，没有修改数据，则不算活跃的可变引用。
* 在一个作用域内， **活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在。

说人话就是：一个可变引用和多个只读引用 在一个作用域内，要么一个可变(写)，要么多个不变(读)。这个约束规则和读写锁(RwLock)非常类似，可以类比学习。

从可变引用的约束我们可以看到，Rust 不但解决了 GC 可以解决的内存安全问题，还解决了 GC 无法解决的问题。
在编写代码的时候， Rust 编译器可以像一个老师一样，不断提示我们采用最佳方案来码出安全的代码。

其实，我们抛开这些上层的规则，搞清楚数据在堆栈中如何存放，在内存中如何访问，然后自下而上理解这些概念，才是最佳途径。

## 总结
这2天我们学习了 Borrow 语义，搞清楚了只读引用和可变引用的原理，结合前面学习的 Move / Copy 语义，Rust 编译器会通过检查，来确保代码没有违背这一系列的规则：
1. 一个值在同一时刻只有一个所有者。当所有者离开作用域，其拥有的值会被丢弃。赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。
2. 如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝，产生新的值。
3. 一个值可以有多个只读引用。
4. 一个值可以有唯一一个活跃的可变引用。可变引用（写）和只读引用（读）是互斥的关系，就像并发下数据的读写互斥那样。
5. 引用的生命周期不能超出值的生命周期。

快速复习：
<img src="" />

产品经理的需求总是多变的，有时候要满足产品的需求就要突破“一个只有一个所有者"的限制。具体怎么做呢？我们明天继续学习。
