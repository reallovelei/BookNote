今天我们一起来啃一下rust学习里的硬骨头--所有权、生命周期。

**这是Rust和其他编程语言的主要区别。也是Rust其他知识点的。**

从变量使用堆栈的行为开始，探究Rust设计所有权和生命周期的用意。

### 先看下变量在函数调用时发生了什么？

这段代码，在main函数里 初始化了一个动态数组data和 一个整形值 v.

然后把他们2个传递给find\_pos函数，

在data中查找v 是否存在，如果存在返回下标，不存返回None。

最后一个语句 直接返回，不用return。

```rust
fn main() {
    let data = vec![10, 42, 9, 8];
    let v = 42;
    if let Some(pos) = find_pos(data, v) {
        println!("Found {} at {}", v, pos);
    }
}

fn find_pos(data: Vec<u32>, v: u32) -> Option<usize> {
    for (pos, item) in data.iter().enumerate() {
        if *item == v {
            return Some(pos);
        }
    }
    
    None
}
```

可以看到 data是动态数组，在编译期无法确定大小，所以实际上是在堆上申请的内存，在栈上有一个包含长度和容量的指针指向堆上的内存。（类似golang的slice，会内存逃逸到堆上）

调用find\_pos的时候 data和v 作为参数传递，放在 find\_pos 的参数区。

现在data 就有2个引用了。

那就会引出一个问题：堆上的内存什么时候释放？

C/C++：手动处理释放，占用码农心智。

Golang:三色标记法。 内存屏障。

PHP：引用计数。

那么Rust是怎么解决的？

先来看一个问题：谁真正拥有数据，值的生杀大权？这种权利是共享的还是独占的？

如何保持独占？ 要考虑的情况还是比较多的。可能造成这个变量的拥有者不唯一

*   变量A被赋给 变量B。
*   变量A作为参数被传递给函数C。
*   作为返回值从函数D返回。

Rust制定了一些规则：

1.  一个值只能被一个变量所拥有，这个变量被称为所有者。（一夫一妻制）
2.  一个值同一时刻 只能有一个所有者。 不能有两个变量拥有相同的值。 函数返回 旧的所有者会把值的所有权 转交给新的所有者。（类似 离婚后 再与其他人结婚？）
3.  当所有者离开作用域，其拥有的值被丢弃。

这三条规则的核心就是保证单一所有权。

规则2里 讲的是所有权转移是Move语义，这个概念Rust是从C++那里借鉴的。

规则3里 提到的作用域，在Rust里主要是指{} 里的代码区， 区分与其他语言一般是函数。

举个例子：

if xx {}里声明的变量，离开这个if后，作用域就结束了。

回到最开始的那段代码，调用findpos的时候，在main里data 的所有权被转移到 find\_pos里的data。

再来看一段代码，对所有权的理解

```rust
fn main() {
	let data = vec![1,2,3,4];
	let data1 = data
}
```

