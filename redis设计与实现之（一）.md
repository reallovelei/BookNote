各位朋友大家好：
  首次见面 先自我介绍一下，我是一名十年的码农，目前就职于。（如果大家有需要可以找内推啊）
      
今天我们来聊聊《Redis设计与实现》这本书。提到Redis相信很多码农都很熟悉。Redis是一个key-value存储系统，和Memcache类似，它支持存储的value类型相对更多，包括string(字符串)、list(列表)、set(集合)、zset(有序集合)和hash 以及订阅/发布等功能。但这本书并不是介绍怎么使用Redis的，而是对Redis的实现原理进行了介绍，力图展示其核心数据结构以及关键的算法思想，并让我们能够快速、有效的了解Redis的内部构造以及其运作机制。敲黑板划重点了，**如果只是对Redis实现原理感兴趣，但是又不想深入研究Redis源代码，那么读这本书就够了。**（这是书上说的，不是我说的啊。我觉得时间充裕的还是可以看完对应章节，看下对应部分代码，毕竟Redis源码并不算多。有问题大家可以留言讨论）。

好，废话不多说，直奔主题。
      

## 简单动态字符串 SDS 
```
struct sdshdr {
	int len; //buf数组中已使用字节的数量,等于SDS所保存字符串的长度
	int free; // buf数组中未使用字节的数量
	char buf[]; // 字节数组，用于保存字符串
}
```

图中示例：

 - free 的值是0，表示这个SDS分配的空间都被用完了。
 - len 的值是5， 表示这个SDS 保存了5个字节长的字符串
 - buf属性是一个char类型的数组，数组的前五个字节分别保存了'R'、'e'、'd'、'i'、's'五个字符，最后一个字节和C字符串一样'\0'表示结束。
（但是最后一个字节'\0'是不计入len的。对SDS的使用者来说是透明的，我觉得这一点还是挺不错的。不用获得以后-1什么的。）



## 如此设计的优点：
感觉这个sds和C字符串的功能差不多都是存字符串的嘛。为毛要多此一举封装一个结构体呢。接下来讨论一下sds的优点。

 1. 获取字符串长度复杂度O(1)。
 2. API安全，杜绝缓冲区溢出：如果buf由小变大，会自动判断buf大小是否足够，如果不够重新申请内存。归一化，避免内存溢出。
 3. 由于SDS的内存分配策略，减少修改字符串时带来的内存重新分配次数。避免频繁申请内存，内存拷贝，等io操作。


## 内存分配策略
 1. 如果申请内存大小 <1M 则直接分配1M内存。
 2. 如果申请内存大小 >1M 如5M 则多分配1M即 5+1M。

## 内存回收策略
惰性回收：刚才我们说了 buf由小变大，sds会自动判断大小，如果内存不足会申请内存，那么如果由大变小呢（如:原大小6M 现在只需要2个字节了），sds会变成1M大小的内存呢？还是维持原有大小64M呢？ 答案是维持原有大小，只是会改变free的值。
关于内存回收策略 我们后面会具体介绍。

留个话题讨论一下，那么Redis的sds最大可以存多大的字符串呢？
    
    

    
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExOTg0MDU3OTZdfQ==
-->
